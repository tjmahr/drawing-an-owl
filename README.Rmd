---
title: "Latent class mixed effects models"
bibliography: refs.bib
output: github_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(
  echo = TRUE,
  collapse = TRUE, 
  dpi = 300,
  out.width = "40%"
)
library(tidyverse)

if (!is.null(knitr::pandoc_to())) {
  set.seed(101)
}
```


This document/repository is an exercise in me "drawing the owl", a
phrase used by Richard McElreath in the [Statistical
Rethinking](https://www.youtube.com/watch?v=FdnMWdICdRs&list=PLDcUM9US4XdPz-KxHM4XHt7uUVGWWVSus)
course to describe the process of the model development. This statistical workflow involves
simulating data, creating statistical models to infer the unobserved
parameters that generated the simulate data, and gradually building up
the model's complexity. And we do this model development *before* we 
plug the real data into the model.

## Background

In @mahr2020, we examined the developmental trajectories of speech
intelligibility in three groups of children with cerebral palsy: those
without speech-motor impairment (NSMI), those with speech-motor
impairment and typical language comprehension (SMI-LCT), and those with
speech-motor impairment and impaired language comprehension (SMI-LCI).
We made these groupings based on clinical judgment for NSMI/SMI status
and language testing for LCT/LCI status. We also tried to make the group
assignments based on age-4 data whenever possible to look at how the
prospective/predictive value of the groups on later growth trajectories.

```{r, out.width = "50%", echo = FALSE}
knitr::include_graphics("previous-paper.png")
```

The NSMI grouping is very successful: All of the children without
dysarthria seem following a homogeneous set of trajectories. The SMI-LCT
grouping seems to two have sets of trajectories: 1) trajectories that
are more spread out than the NSMI group but do show reliable growth in
intelligibility, and 2) 4--5 trajectories that show very limited growth.
The SMI-LCI group is less numerous than the other groups but it seems to
have a lower average trajectories than the others. 

So, these groupings provide a coarse ordering for severity of
impairment, but can we do better? Actually, that's not the right
question: Can we do different? What if instead we tell the statistical
model that there are K latent subgroups in our sample? Can it identify K
different groups? Is there evidence in the data for K groups? What about
K-1 or K+1 groups? Do the model-uncovered groups match up with our
previously defined groups? Those are just a few of the questions that 
spring to mind. 

I would like to apply a latent class mixed models approach to our 
intelligibility trajectories but there is no off-the-shelf solution for 
this problem, at least not one that can accommodate the nonlinear growth 
model and beta distribution family I used in my prior analysis. 

## Math of latent class mixed models

The [lcmm](https://cecileproust-lima.github.io/lcmm/) R package provides a maximum-likelihood estimate for gaussian 
latent class mixed models, so that is a good starting point for understanding these models.

@JSSv078i02 describe the statistical machinery for their latent class
mixed models. We note the following equations from their paper.

Below is the likelihood contribution for one individual in the basic
linear mixed model that we know and love:

$$
\displaylines{
L_i = \phi_i(Y_i; \theta_1) \\
\phi: \textrm{MVN density} \\
i: \textrm{individual index}
}
$$

When there are $G$ latent classes, the likelihood becomes a weighted sum
of class-specific likelihoods:

$$
\displaylines{
L_i(\theta_G) = \sum_{g=1}^G \pi_{ig}\phi_{ig}(Y_i|c_i = g; \theta_G) \\
\pi_{ig}: \textrm{probability of group membership for an individual} \\
g: \textrm{group index}
}
$$


So, an individual makes $G$ contributions to the likelihood and each one
is weighted by their group membership probability. And when there is one
group, this equation reduces to the first likelihood equation.

Finally, group probabilities are defined as a multinomial logistic
model:

$$
\displaylines{
\pi_{ig} = 
  P(c_i = g | X_{ci}) = 
  \frac{
    e^{\xi_{0g} +X^{\top}_{ci}\xi_{1g}}
  }{
    \sum^{G}_{l=1}e^{\xi_{0l} +X^{\top}_{ci}\xi_{1l}}
  } \\
c_i : \textrm{the latent class for an individual} \\
X_{ci} : \textrm{time-indpendent covariates} \\
\xi_{0g} +X^{\top}_{ci}\xi_{1g} : \textrm{linear model for group membership}
}
$$


## Marginalization of discrete parameters

Richard McElreath has a
[tutorial](https://elevanth.org/blog/2018/01/29/algebra-and-missingness/)
where observations are in different states but for some observations,
that state is missing/unobserved. He provides following recipe for how 
work with discrete parameters in Stan:

> 
> (1) Write the probability of an outcome `y[i]` conditional on known values
> of the discrete parameters. Call this $L$, the conditional likelihood.
> 
> (2) List all the possible states the discrete parameters could take. For
> example, if you have two binary parameters, then there are four possible
> states: 11, 10, 01, and 00. Let $j$ be an index for state, so that in
> this example $j$ can take the values 1, 2, 3, and 4.
> 
> (3) For each state in (2), compute the probability of that state. Your
> model provides these probabilities, and they will depend upon the
> details of your model. Call each state's probability $P_j$.
> 
> (4) For each state in (2), compute the probability of an outcome `y[i]`
> when the discrete parameters take on those values. For example, there is
> a different probability for each of 11, 10, 01, and 00. You can use the
> expression from (1) and just insert the values of the parameters for
> each state. Call each state's corresponding likelihood $L_j$.
> 
> (5) Now you can compute the unconditional probability of `y[i]` by
> multiplying each $P_j$ by $L_j$. Then sum these products for all
> states: $M=\sum_j P_j L_j$. This $M$ is the marginal likelihood, the
> probability of `y[i]` averaging over the unknown values of the discrete
> parameters.
> 
> In the actual code, we must do all of the above on the log-probability
> scale, or otherwise numerical precision will be poor. So in practice
> each $P_j L_j$ term is computed as a sum of log probabilities:
> `term[j] = logP[j] + logL[j]`. And then we can compute $\log M$ as
> `log_sum_exp(term).`


## A Gaussian mixture model

Following that recipe and the notes from the lcmm package, I can do a simple 
latent class model in Stan:

```{r}
# knitr::opts_chunk$set(eval = FALSE)
```


```{r}
m <- cmdstanr::cmdstan_model("0.stan")
```

```{embed, file="0.stan"}
```

In the double for-loop in the model block, we perform the
marginalization recipe. We iterate through the observations and compute
weighted likelihoods for each group by multiplying the group probability
times the likelihood of the observation in that group.

Let's try to replicate the [Gaussian Mixture Model
demo](https://www.pymc.io/projects/examples/en/latest/mixture_models/gaussian_mixture_model.html)
from PyMC.

```{r}
library(dplyr)
library(ggplot2)
library(patchwork)

n_groups <- 3
n_obs <- 500
means <- c(-5, 0, 5)
sds = c(0.5, 2.0, 0.75)
ids <- sample(1:n_groups, n_obs, replace = TRUE)
y <- rnorm(n_obs, means[ids], sds[ids])

true_values <- tibble(
  parameter = c(
    sprintf("mean_group[%s]", 1:3),
    sprintf("probs[%s]", 1:3),
    sprintf("sigma_group[%s]", 1:3)
  ),
  ground_truth = c(
    means, rep(.33, 3), sds
  )
)

data <- list(
  n_obs = length(y),
  n_groups = 3,
  y = y,
  will_calculate_probs = 0
)

posterior_gmm <- m$sample(data, refresh = 0, parallel_chains = 4)
```


```{r gmm1, fig.height = 3, fig.width = 8, out.width = "100%"}
tidy_gmm_draws <- function(x) {
  x$draws() |> 
    posterior::as_draws_df() |>
    tibble::as_tibble() |> 
    select(
      .draw, .chain,
      starts_with("mean_"), 
      starts_with("probs"), 
      starts_with("sigma")
    ) |> 
    tidyr::pivot_longer(
      cols = c(-.draw, -.chain), 
      names_pattern = "(.+)\\[(\\d+)\\]",
      names_to = c("family", "index")
    ) |> 
    mutate(parameter = sprintf("%s[%s]", family, index))
}

draws_gmm <- posterior_gmm |> 
  tidy_gmm_draws()  |> 
    left_join(true_values, by = "parameter")

p <- ggplot(tibble(x = y)) + 
  aes(x = x) + 
  ggdist::geom_swarm(color = "black") +
  ggtitle("data") +
  xlab("observed value") +
  theme(axis.text.y = element_blank(), axis.ticks.y = element_blank())


p2 <- ggplot(draws_gmm) + 
  aes(x = value, y = index) + 
  ggdist::stat_pointinterval() + 
  facet_wrap("family", scales = "free") +
  geom_point(
    aes(x = ground_truth, color = "ground truth"), 
    position = position_nudge(y = .2),
    color = "orangered"
  ) +
  ggtitle("model") +
  guides(color = "none")

p + p2 + plot_layout(widths = c(1, 2))
```

There is another PyMC demo that sets the prevalences of groups too. Let's try 
that.

```{r gmm2, fig.height = 3, fig.width = 8, out.width = "100%"}
n_groups <- 3
n_obs <- 1000
probs <- c(0.35, 0.4, 0.25)
means <- c(0.0, 2.0, 5.0)
sds = c(0.5, 0.5, 1.0)
ids <- sample(1:n_groups, n_obs, prob = probs, replace = TRUE)
table(ids) / n_obs
y <- rnorm(n_obs, means[ids], sds[ids])

true_values <- tibble::tibble(
  parameter = c(
    sprintf("mean_group[%s]", 1:3),
    sprintf("probs[%s]", 1:3),
    sprintf("sigma_group[%s]", 1:3)
  ),
  ground_truth = c(means, probs, sds)
)

data <- list(
  n_obs = length(y),
  n_groups = 3,
  y = y,
  will_calculate_probs = 0
)

e <- m$sample(data, refresh = 0, parallel_chains = 4)
e_sum <- e$summary()

draws_gmm <- e |> 
  tidy_gmm_draws()  |> 
    left_join(true_values, by = "parameter")

p <- ggplot(tibble(x = y)) + 
  aes(x = x) + 
  ggdist::geom_swarm(color = "black") +
  ggtitle("data") +
  xlab("observed value") +
  theme(axis.text.y = element_blank(), axis.ticks.y = element_blank())


p2 <- ggplot(draws_gmm) + 
  aes(x = value, y = index) + 
  ggdist::stat_pointinterval() + 
  facet_wrap("family", scales = "free") +
  geom_point(
    aes(x = ground_truth, color = "ground truth"), 
    position = position_nudge(y = .2),
    color = "orangered"
  ) +
  ggtitle("model") +
  guides(color = "none")

p + p2 + plot_layout(widths = c(1, 2))
```



## sketch

  - stan code for a random-intercept with no latent groups model
  - update said model to have latent groups

Simulate some repeated measures data. There are no latent group effects yet.
Happy with the idea of storing stuff in dataframe and joining at the
end, not happy with the verbosity.

```{r}
library(tidyverse)
rep_along <- function (along, x) rep_len(x, length(along))

simulate_data <- function(
  n_individuals = 20,
  n_obs = 100,
  n_groups = 3,
  sigma_y = .2,
  group_mean = NULL,
  group_sigma = NULL
) {
  if (is.null(group_mean)) {
    group_mean <- rep_len(0, n_groups)
    group_sigma <- rep_len(1, n_groups)
  }
  if (is.null(group_sigma)) {
    group_sigma <- rep_len(1, n_groups)
  }
  
  d_groups <- data.frame(
    group = seq_len(n_groups),
    group_mean = group_mean,
    group_sigma = group_sigma
  )
  
  d_observations <- data.frame(
    y = rep_len(NA, n_obs),
    individual = NA_integer_
  )
  
  d_individuals <- data.frame(
    individual = seq_len(n_individuals),
    group = NA_integer_,
    individual_mean = NA_real_
  )

  d_individuals$group <- sample(
    seq_len(n_groups), 
    n_individuals, 
    replace = TRUE
  )

  d_observations$individual <- sample(
    d_individuals$individual, 
    n_obs, 
    replace = TRUE
  )

  d_individuals$individual_mean <- rnorm(
    n_individuals,
    d_groups$group_mean[d_individuals$group],
    d_groups$group_sigma[d_individuals$group]
  )

  d_observations$y <- rnorm(
    n_obs,
    d_individuals$individual_mean[d_observations$individual], 
    sigma_y
  )

  d_observations |> 
    left_join(d_individuals, by = join_by(individual)) |> 
    left_join(d_groups, by = join_by(group)) |> 
    mutate(sigma_y = sigma_y)
}

d <- simulate_data()

```

Run a simple Stan model and check that it recovers the parameters.

```{r simple-ri-model, fig.width = 6, fig.height = 3, out.width="80%"}
m <- cmdstanr::cmdstan_model("1.stan")
data <- list(
  n_obs = nrow(d),
  n_ind = length(unique(d$individual)),
  individual = d$individual,
  n_groups = length(unique(d$group)),
  y = d$y
)
e <- m$sample(data, refresh = 0)
e_sum <- e$summary()

d_post_individuals <- e_sum |> 
  filter(variable |> startsWith("coef_b[")) |> 
  mutate(
    individual = readr::parse_number(variable),
    type = "alpha + ranef"
  ) |> 
  left_join(
    d |> distinct(individual, individual_mean), 
    by = join_by(individual)
  )

ggplot(d_post_individuals) + 
  aes(x = individual) + 
  geom_linerange(
    aes(ymin = q5, ymax = q95, color = "posterior 90%\n(inferred latent mean)"), 
  ) +
  geom_point(
    aes(y = individual_mean, color = "latent mean"),
    size = 3,
    alpha = .8
  ) + 
  geom_point(
    aes(y = y, color = "observed mean"),
    data = d,
    alpha = .8,
    stat = "summary",
    size = 3,
  ) +
  guides(
    color = guide_legend(
      override.aes = list(shape = c(19, 19, NA), linewidth = c(NA, NA, .5))
    )
  ) + 
  facet_wrap("type") +
  scale_color_manual(
    "quantities",
    values = palette.colors(3)[c(2, 3, 1)] |> unname()
  )
```

```{r simple-ri-model-2, fig.height = 3, fig.width = 4}
e_sum |> 
  filter(variable %in% c("alpha", "sigma_b", "sigma_y")) |> 
  left_join(
    d |> 
      distinct(group_mean, group_sigma, sigma_y) |> 
      rename(sigma_b = group_sigma, alpha = group_mean) |> 
      tidyr::pivot_longer(
        everything(), 
        names_to = "variable", 
        values_to = "value"
      )
  ) |> 
  ggplot() + 
    aes(x = variable) + 
    geom_linerange(aes(ymin = q5, ymax = q95)) +
    geom_point(
      aes(y = value),
      color = "blue",
      size = 3,
      alpha = .3
    )
```


## Assignment to groups

Let's assume the individuals belong to latent groups. 
```{r latent-groups, out.width = "80%", fig.width = 6, fig.height = 3}
d <- simulate_data(
  n_groups = 3, 
  group_mean = c(-3, 1, 3.5)
)

ggplot(d) + 
  aes(x = individual, y = y) + 
  geom_point(aes(color = factor(group))) +
  geom_point(aes(y = individual_mean))

```

The random intercept model does okay.

```{r simple-ri-model-3, fig.width = 6, fig.height = 3, out.width="80%"}
m <- cmdstanr::cmdstan_model("1.stan")

data <- list(
  n_obs = nrow(d),
  n_ind = length(unique(d$individual)),
  individual = d$individual,
  n_groups = length(unique(d$group)),
  y = d$y
)
e <- m$sample(data, refresh = 0)
e_sum <- e$summary()

d_post_individuals <- e_sum |> 
  filter(variable |> startsWith("coef_b[")) |> 
  mutate(
    individual = readr::parse_number(variable),
    type = "alpha + ranef"
  ) |> 
  left_join(
    d |> distinct(individual, individual_mean), 
    by = join_by(individual)
  )

ggplot(d_post_individuals) + 
  aes(x = individual) + 
  geom_linerange(
    aes(ymin = q5, ymax = q95, color = "posterior 90%\n(inferred latent mean)"), 
  ) +
  geom_point(
    aes(y = individual_mean, color = "latent mean"),
    size = 3,
    alpha = .8
  ) + 
  geom_point(
    aes(y = y, color = "observed mean"),
    data = d,
    alpha = .8,
    stat = "summary",
    size = 3,
  ) +
  guides(
    color = guide_legend(
      override.aes = list(shape = c(19, 19, NA), linewidth = c(NA, NA, .5))
    )
  ) + 
  facet_wrap("type") +
  scale_color_manual(
    "quantities",
    values = palette.colors(3)[c(2, 3, 1)] |> unname()
  )
```

```{r, eval = FALSE}
m <- cmdstanr::cmdstan_model("2.stan")
data <- list(
  n_obs = nrow(d),
  n_ind = length(unique(d$individual)),
  individual = d$individual,
  n_groups = length(unique(d$group)),
  y = d$y
)
e <- m$sample(data, refresh = 0)
e_sum <- e$summary()
e_sum |> print(n = Inf)
```
